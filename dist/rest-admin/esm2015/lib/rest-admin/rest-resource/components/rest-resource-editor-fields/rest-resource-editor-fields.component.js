import { Component, ViewChild } from "@angular/core";
import { FileUploadControl, FileUploadValidators, } from "@iplab/ngx-file-upload";
import { DefaultEditor } from "ng2-smart-table";
import { BehaviorSubject, of } from "rxjs";
import { map } from "rxjs/operators";
import { REST_FIELD_TYPES } from "../../models/rest-resource.model";
import { base64ToFile } from "ngx-image-cropper";
import * as _ from "lodash";
import * as i0 from "@angular/core";
import * as i1 from "../../service/rest-admin-config.service";
import * as i2 from "../../service/rest-resource.service";
import * as i3 from "@nebular/theme";
import * as i4 from "@iplab/ngx-file-upload";
import * as i5 from "ngx-image-cropper";
import * as i6 from "@angular/common";
import * as i7 from "@angular/forms";
export class RestResourceEditorFieldsComponent extends DefaultEditor {
    constructor(serviceRestAdminConfig, serviceResResource) {
        super();
        this.serviceRestAdminConfig = serviceRestAdminConfig;
        this.serviceResResource = serviceResResource;
        // Test
        this.uploadedFile = new BehaviorSubject(null);
        // Control sur les fichiers a upload
        this.control = new FileUploadControl({
            listVisible: true,
            accept: ["image/*"],
            discardInvalid: true,
            multiple: false,
        }, [
            FileUploadValidators.accept(["image/*"]),
            FileUploadValidators.filesLimit(1),
        ]);
        this.controlCroper = null;
        this.croppedImage = "";
        this.isCrop = false;
    }
    // End test
    ngOnInit() {
        this.subscription = this.control.valueChanges.subscribe((values) => {
            this.getImage(values[0]);
            this.controlCroper = values[0];
        });
        this.infoRows = this.cell.getColumn().valuePrepareFunction();
        this.field = this.infoRows.restField;
        switch (this.field.type) {
            case REST_FIELD_TYPES.HAS_MANY:
                this.cell.newValue = new Set([]);
                break;
            case REST_FIELD_TYPES.BELONG_TO:
                const restResource = this.serviceRestAdminConfig.getSpecificResource(this.field.metaData.addConfig.belongToOptions.resourceName);
                this.serviceResResource
                    .getResources({
                    api: restResource.api,
                    queryParams: this.field.metaData.addConfig.belongToOptions
                        .queryParams
                        ? this.field.metaData.addConfig.belongToOptions.queryParams
                        : restResource.queryParams,
                })
                    .subscribe((response) => {
                    this.options = response;
                    this.filteredOptions$ = of(this.options);
                });
                break;
            case REST_FIELD_TYPES.BELONG_TO_MANY:
                this.cell.newValue = new Set([]);
                const resource = this.serviceRestAdminConfig.getSpecificResource(this.field.metaData.addConfig.belongToManyOptions.relatedName);
                this.serviceResResource
                    .getResources({
                    api: resource.api,
                    queryParams: this.field.metaData.addConfig.belongToManyOptions
                        .queryParams
                        ? this.field.metaData.addConfig.belongToManyOptions.queryParams
                        : resource.queryParams,
                })
                    .subscribe((response) => {
                    this.options = response;
                    this.filteredOptions$ = of(this.options);
                });
                break;
            case REST_FIELD_TYPES.IMAGE:
            case REST_FIELD_TYPES.FILE:
                this.cell.newValue = [];
                break;
            case REST_FIELD_TYPES.BOOLEAN:
                this.cell.newValue = false;
                break;
            // case REST_FIELD_TYPES.PDF:
            // this.cell.newValue = [];
            // break;
            default:
                break;
        }
    }
    get REST_FIELD_TYPES() {
        return REST_FIELD_TYPES;
    }
    // Tags
    onTagRemove(tagToRemove) {
        const treesA = new Set(this.cell.newValue);
        treesA.delete(tagToRemove.text);
        this.cell.newValue = Array.from(treesA.values());
    }
    onTagAdd({ value, input }) {
        if (value) {
            const treesA = new Set(this.cell.newValue);
            treesA.add(value);
            this.cell.newValue = Array.from(treesA.values());
        }
        input.nativeElement.value = "";
    }
    // End tag
    // Autocomplete
    filter(value) {
        if (typeof value == "string") {
            return this.options.filter((optionValue) => {
                return this.field.metaData.addConfig.belongToOptions.filterKeys.some((elt) => `${optionValue[elt].toLowerCase()}`.includes(`${value.toLowerCase()}`));
            });
        }
    }
    getFilteredOptions(value) {
        return of(value).pipe(map((filterString) => this.filter(filterString)));
    }
    onChange() {
        this.filteredOptions$ = this.getFilteredOptions(this.input.nativeElement.value);
    }
    onSelectionChange($event) {
        this.filteredOptions$ = this.getFilteredOptions($event);
    }
    // End Autocomplete
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    getImage(file) {
        if (FileReader && file) {
            const fr = new FileReader();
            fr.onload = (e) => {
                this.uploadedFile.next(e.target.result);
            };
            fr.readAsDataURL(file);
        }
        else {
            this.uploadedFile.next(null);
        }
    }
    imageCropped(event) {
        this.croppedImage = event.base64;
    }
    activeCroper() {
        this.isCrop = true;
    }
    saveCroper() {
        this.isCrop = false;
        this.uploadedFile.next(this.croppedImage);
        this.cell.setValue(base64ToFile(this.croppedImage));
    }
    //belongToManyOptions
    onChoose(event) {
        const cellData = Array.from(this.cell.newValue.values());
        if (event) {
            const search = cellData.find((elt) => elt.id == event.id);
            if (search == undefined) {
                const newElt = {
                    id: event.id,
                    [this.field.metaData.addConfig.belongToManyOptions.relatedIdName]: event.id,
                    [this.field.metaData.addConfig.belongToManyOptions.resourceIdName]: "",
                    [this.field.metaData.addConfig.belongToManyOptions.filterKeys[0]]: event[this.field.metaData.addConfig.belongToManyOptions.filterKeys[0]],
                    saveRelatedIdName: this.field.metaData.addConfig.belongToManyOptions.relatedIdName,
                    saveResourceIdName: this.field.metaData.addConfig.belongToManyOptions.resourceIdName,
                };
                const treesA = new Set(this.cell.newValue);
                treesA.add(newElt);
                this.cell.newValue = Array.from(treesA.values());
            }
        }
        this.inputBelongTo.nativeElement.value = "";
    }
    onTagRemoveBelong(tagToRemove) {
        const cellData = Array.from(this.cell.newValue.values());
        const save = [];
        cellData.forEach((elt) => {
            if (elt[this.field.metaData.addConfig.belongToManyOptions.template
                ? this.field.metaData.addConfig.belongToManyOptions.template
                : this.field.metaData.addConfig.belongToManyOptions.filterKeys[0]].localeCompare(tagToRemove.text) != 0)
                save.push(elt);
        });
        this.cell.newValue = Array.from(save);
    }
    //End BelongToMany
    getField(fields, value) {
        return _.get(fields, value);
    }
}
RestResourceEditorFieldsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.5", ngImport: i0, type: RestResourceEditorFieldsComponent, deps: [{ token: i1.RestAdminConfigService }, { token: i2.RestResourceService }], target: i0.ɵɵFactoryTarget.Component });
RestResourceEditorFieldsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "12.1.5", type: RestResourceEditorFieldsComponent, selector: "input-editor", viewQueries: [{ propertyName: "input", first: true, predicate: ["autoInput"], descendants: true }, { propertyName: "inputBelongTo", first: true, predicate: ["autoInputBelongToMany"], descendants: true }], usesInheritance: true, ngImport: i0, template: "<ng-container *ngIf=\"field.inForm == true\">\n  <!-- Input type string -->\n  <input\n    type=\"text\"\n    *ngIf=\"field.type == REST_FIELD_TYPES.STRING\"\n    [(ngModel)]=\"cell.newValue\"\n    [name]=\"cell.getId()\"\n    [placeholder]=\"cell.getTitle()\"\n    [disabled]=\"!cell.isEditable()\"\n    (click)=\"onClick.emit($event)\"\n    (keydown.enter)=\"onEdited.emit($event)\"\n    (keydown.esc)=\"onStopEditing.emit()\"\n    class=\"form-control ng-valid ng-touched ng-dirty\"\n    fullWidth\n  />\n\n  <!-- Input type text -->\n  <textarea\n    [(ngModel)]=\"cell.newValue\"\n    [name]=\"cell.getId()\"\n    [placeholder]=\"cell.getTitle()\"\n    [disabled]=\"!cell.isEditable()\"\n    (click)=\"onClick.emit($event)\"\n    (keydown.enter)=\"onEdited.emit($event)\"\n    (keydown.esc)=\"onStopEditing.emit()\"\n    class=\"form-control ng-valid ng-touched ng-dirty\"\n    *ngIf=\"field.type == REST_FIELD_TYPES.TEXT\"\n    fullWidth\n  ></textarea>\n\n  <!-- Input type number  -->\n  <input\n    [(ngModel)]=\"cell.newValue\"\n    [name]=\"cell.getId()\"\n    [placeholder]=\"cell.getTitle()\"\n    [disabled]=\"!cell.isEditable()\"\n    (click)=\"onClick.emit($event)\"\n    (keydown.enter)=\"onEdited.emit($event)\"\n    (keydown.esc)=\"onStopEditing.emit()\"\n    class=\"form-control ng-valid ng-touched ng-dirty\"\n    type=\"number\"\n    fullWidth\n    *ngIf=\"field.type == REST_FIELD_TYPES.NUMBER\"\n  />\n\n  <!-- Input type date -->\n  <input\n    *ngIf=\"field.type == REST_FIELD_TYPES.DATE\"\n    [nbDatepicker]=\"formpicker\"\n    [(ngModel)]=\"cell.newValue\"\n    [name]=\"cell.getId()\"\n    [placeholder]=\"cell.getTitle()\"\n    [disabled]=\"!cell.isEditable()\"\n    (click)=\"onClick.emit($event)\"\n    (keydown.enter)=\"onEdited.emit($event)\"\n    (keydown.esc)=\"onStopEditing.emit()\"\n    class=\"form-control ng-valid ng-touched ng-dirty\"\n    fullWidth\n  />\n  <nb-datepicker #formpicker></nb-datepicker>\n\n  <!-- Input type dateTime -->\n  <ng-container *ngIf=\"field.type == REST_FIELD_TYPES.DATETIME\">\n    <input\n      nbInput\n      [nbDatepicker]=\"dateTimePicker\"\n      [(ngModel)]=\"cell.newValue\"\n      [name]=\"cell.getId()\"\n      [placeholder]=\"cell.getTitle()\"\n      [disabled]=\"!cell.isEditable()\"\n      (click)=\"onClick.emit($event)\"\n      (keydown.enter)=\"onEdited.emit($event)\"\n      (keydown.esc)=\"onStopEditing.emit()\"\n      class=\"form-control ng-valid ng-touched ng-dirty\"\n      fullWidth\n    />\n    <nb-date-timepicker withSeconds #dateTimePicker></nb-date-timepicker>\n  </ng-container>\n\n  <!-- Input type time -->\n  <ng-container *ngIf=\"field.type == REST_FIELD_TYPES.TIME\">\n    <input\n      [nbTimepicker]=\"timepicker\"\n      twelveHoursFormat]\n      nbInput\n      [(ngModel)]=\"cell.newValue\"\n      [name]=\"cell.getId()\"\n      [placeholder]=\"cell.getTitle()\"\n      [disabled]=\"!cell.isEditable()\"\n      (click)=\"onClick.emit($event)\"\n      (keydown.enter)=\"onEdited.emit($event)\"\n      (keydown.esc)=\"onStopEditing.emit()\"\n      class=\"form-control ng-valid ng-touched ng-dirty\"\n      fullWidth\n    />\n    <nb-timepicker #timepicker></nb-timepicker>\n  </ng-container>\n\n  <!-- Input type enum -->\n  <nb-select\n    [(ngModel)]=\"cell.newValue\"\n    [name]=\"cell.getId()\"\n    (change)=\"onClick.emit($event)\"\n    class=\"input-space\"\n    *ngIf=\"field.type == REST_FIELD_TYPES.ENUM\"\n    nbInput\n  >\n    <nb-option\n      *ngFor=\"let option of field.metaData.addConfig.enumOptions\"\n      [value]=\"option.value\"\n      >{{ option.label }}</nb-option\n    >\n  </nb-select>\n\n  <!-- Input type Boolean -->\n  <div\n    style=\"text-align: center\"\n    *ngIf=\"field.type == REST_FIELD_TYPES.BOOLEAN\"\n  >\n    <nb-toggle [name]=\"cell.getId()\" [(ngModel)]=\"cell.newValue\"></nb-toggle>\n  </div>\n\n  <ng-container *ngIf=\"field.type == REST_FIELD_TYPES.FILE\">\n    <file-upload\n      [(ngModel)]=\"cell.newValue\"\n      class=\"input-space\"\n      [name]=\"field.label\"\n      style=\"min-width: 300px; max-width: 300px\"\n    ></file-upload>\n  </ng-container>\n\n  <ng-container *ngIf=\"field.type == REST_FIELD_TYPES.PDF\">\n    <file-upload\n      [(ngModel)]=\"cell.newValue\"\n      class=\"input-space\"\n      [name]=\"field.label\"\n      style=\"min-width: 300px; max-width: 300px\"\n    ></file-upload>\n    <object width=\"300px\" height=\"300px\" [data]=\"cell.newValue[0]\"></object>\n  </ng-container>\n\n  <ng-container *ngIf=\"field.type == REST_FIELD_TYPES.IMAGE\">\n    <!-- [(ngModel)]=\"cell.newValue\"\n    class=\"file-image\"\n    [name]=\"field.label\" -->\n    <file-upload\n      [control]=\"control\"\n    >\n      <ng-template\n        let-isFileDragDropAvailable=\"isFileDragDropAvailable\"\n        #placeholder\n      >\n        <div *ngIf=\"control.size === 0\">\n          <svg viewBox=\"0 0 512 512\" class=\"icon\">\n            <path\n              d=\"M296 384h-80c-13.3 0-24-10.7-24-24V192h-87.7c-17.8 0-26.7-21.5-14.1-34.1L242.3 5.7c7.5-7.5 19.8-7.5 27.3 0l152.2 152.2c12.6 12.6 3.7 34.1-14.1 34.1H320v168c0 13.3-10.7 24-24 24zm216-8v112c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V376c0-13.3 10.7-24 24-24h136v8c0 30.9 25.1 56 56 56h80c30.9 0 56-25.1 56-56v-8h136c13.3 0 24 10.7 24 24zm-124 88c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20zm64 0c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20z\"\n            ></path>\n          </svg>\n\n          <div class=\"upload-text\">\n            <ng-container\n              *ngIf=\"isFileDragDropAvailable; else isNotDragDropAvailable\"\n            >\n              <b>Drag and drop</b> files<br />\n              or click here\n            </ng-container>\n            <ng-template #isNotDragDropAvailable>\n              <b>Click here</b> to<br />\n              choose a files\n            </ng-template>\n          </div>\n        </div>\n      </ng-template>\n\n      <ng-template let-i=\"index\" let-file=\"file\" let-control=\"control\" #item>\n        <div class=\"overlay\">\n          <svg\n            viewBox=\"0 0 448 512\"\n            class=\"delete-button\"\n            (click)=\"control.removeFile(file)\"\n          >\n            <path\n              d=\"M32 464a48 48 0 0 0 48 48h288a48 48 0 0 0 48-48V128H32zm272-256a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zm-96 0a16 16 0 0 1 32 0v224a16 16 0 0 1-32 0zM432 32H312l-9.4-18.7A24 24 0 0 0 281.1 0H166.8a23.72 23.72 0 0 0-21.4 13.3L136 32H16A16 16 0 0 0 0 48v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16z\"\n            ></path>\n          </svg>\n          <img *ngIf=\"control.valid\" [src]=\"uploadedFile | async\" />\n        </div>\n      </ng-template>\n    </file-upload>\n\n    <button\n      nbButton\n      status=\"primary\"\n      *ngIf=\"!isCrop && controlCroper != null\"\n      (click)=\"activeCroper()\"\n    >\n      CROP\n    </button>\n\n    <ng-container *ngIf=\"isCrop\">\n      <image-cropper\n        [imageFile]=\"controlCroper\"\n        [maintainAspectRatio]=\"true\"\n        [aspectRatio]=\"4 / 3\"\n        format=\"png\"\n        (imageCropped)=\"imageCropped($event)\"\n      ></image-cropper>\n\n      <button nbButton status=\"primary\" (click)=\"saveCroper()\">\n        SAVE CHANGE\n      </button>\n    </ng-container>\n\n    <!-- <img [src]=\"croppedImage\" /> -->\n  </ng-container>\n\n  <!-- Input type  -->\n  <ng-container *ngIf=\"field.type == REST_FIELD_TYPES.HAS_MANY\">\n    <nb-tag-list (tagRemove)=\"onTagRemove($event)\" class=\"input-space\">\n      <nb-tag\n        *ngFor=\"let tree of cell.newValue\"\n        [text]=\"tree\"\n        removable\n      ></nb-tag>\n      <input type=\"text\" nbTagInput (tagAdd)=\"onTagAdd($event)\" fullWidth />\n    </nb-tag-list>\n  </ng-container>\n\n  <ng-container *ngIf=\"field.type == REST_FIELD_TYPES.BELONG_TO\">\n    <input\n      #autoInput\n      nbInput\n      type=\"text\"\n      (input)=\"onChange()\"\n      placeholder=\"Enter value\"\n      [nbAutocomplete]=\"auto\"\n      [(ngModel)]=\"cell.newValue\"\n    />\n\n    <nb-autocomplete #auto (selectedChange)=\"onSelectionChange($event)\">\n      <nb-option\n        *ngFor=\"let option of filteredOptions$ | async\"\n        [value]=\"\n          option[\n            field?.metaData?.addConfig.belongToOptions?.value\n              ? field?.metaData?.addConfig?.belongToOptions?.value\n              : 'id'\n          ]\n        \"\n      >\n        {{\n          option[\n            field.metaData.addConfig.belongToOptions.template\n              ? field.metaData.addConfig.belongToOptions.template\n              : field.metaData.addConfig.belongToOptions.filterKeys[0]\n          ]\n        }}\n      </nb-option>\n    </nb-autocomplete>\n  </ng-container>\n\n  <ng-container *ngIf=\"field.type == REST_FIELD_TYPES.BELONG_TO_MANY\">\n    <div>\n      <nb-tag-list (tagRemove)=\"onTagRemoveBelong($event)\" class=\"input-space\">\n        <nb-tag\n          *ngFor=\"let tree of cell.newValue\"\n          [text]=\"\n            tree[\n              field.metaData.addConfig.belongToManyOptions.template\n                ? field.metaData.addConfig.belongToManyOptions.template\n                : field.metaData.addConfig.belongToManyOptions.filterKeys[0]\n            ]\n          \"\n          removable\n        ></nb-tag>\n        <input\n          type=\"text\"\n          nbTagInput\n          #autoInputBelongToMany\n          [nbAutocomplete]=\"autoBelonToMany\"\n          (tagAdd)=\"onTagAdd($event)\"\n          fullWidth\n        />\n\n        <nb-autocomplete #autoBelonToMany (selectedChange)=\"onChoose($event)\">\n          <nb-option\n            *ngFor=\"let option of filteredOptions$ | async\"\n            [value]=\"option\"\n          >\n            {{\n              option[\n                field.metaData.addConfig.belongToManyOptions.template\n                  ? field.metaData.addConfig.belongToManyOptions.template\n                  : field.metaData.addConfig.belongToManyOptions.filterKeys[0]\n              ]\n            }}\n          </nb-option>\n        </nb-autocomplete>\n      </nb-tag-list>\n    </div>\n  </ng-container>\n</ng-container>\n", styles: [".icon{height:35px;width:35px;line-height:30px;text-align:center;border:1px solid #eaeaea;border-radius:4px;float:left;margin-right:20px}.upload-text{overflow:hidden;width:auto;font-size:14px}svg{fill:#909293;height:20px}.overlay{position:relative}.delete-button{background-color:#fafafa;position:absolute;top:-6px;right:-6px;cursor:pointer;z-index:10;width:40px;height:40px;text-align:center;font-size:20px;line-height:40px}.file-image{min-width:300px;max-width:300px}.file-image img{width:100%}nb-toggle{text-align:center}\n"], components: [{ type: i3.NbDatepickerComponent, selector: "nb-datepicker", inputs: ["date"], outputs: ["dateChange"] }, { type: i3.NbDateTimePickerComponent, selector: "nb-date-timepicker", inputs: ["twelveHoursFormat", "withSeconds", "singleColumn", "step", "title", "applyButtonText", "currentTimeButtonText"] }, { type: i3.NbTimePickerComponent, selector: "nb-timepicker", inputs: ["showFooter", "timeFormat", "twelveHoursFormat", "withSeconds", "singleColumn", "step", "date", "hoursText", "minutesText", "secondsText", "ampmText", "applyButtonText", "currentTimeButtonText"], outputs: ["onSelectTime"], exportAs: ["nbTimepicker"] }, { type: i3.NbSelectComponent, selector: "nb-select", inputs: ["size", "status", "shape", "appearance", "placeholder", "optionsOverlayOffset", "scrollStrategy", "outline", "filled", "hero", "disabled", "fullWidth", "compareWith", "selected", "multiple", "optionsListClass", "optionsPanelClass"], outputs: ["selectedChange"] }, { type: i3.NbOptionComponent, selector: "nb-option", inputs: ["disabled", "value"], outputs: ["selectionChange"] }, { type: i3.NbToggleComponent, selector: "nb-toggle", inputs: ["status", "labelPosition", "checked", "disabled"], outputs: ["checkedChange"] }, { type: i4.FileUploadComponent, selector: "file-upload:not([simple])", inputs: ["control", "animation", "multiple"] }, { type: i3.NbButtonComponent, selector: "button[nbButton],a[nbButton],input[type=\"button\"][nbButton],input[type=\"submit\"][nbButton]", inputs: ["hero"] }, { type: i5.ImageCropperComponent, selector: "image-cropper", inputs: ["imageChangedEvent", "imageURL", "imageBase64", "imageFile", "format", "transform", "maintainAspectRatio", "aspectRatio", "resetCropOnAspectRatioChange", "resizeToWidth", "resizeToHeight", "cropperMinWidth", "cropperMinHeight", "cropperMaxHeight", "cropperMaxWidth", "cropperStaticWidth", "cropperStaticHeight", "canvasRotation", "initialStepSize", "roundCropper", "onlyScaleDown", "imageQuality", "autoCrop", "backgroundColor", "containWithinAspectRatio", "hideResizeSquares", "allowMoveImage", "cropper", "alignImage", "disabled", "hidden"], outputs: ["imageCropped", "startCropImage", "imageLoaded", "cropperReady", "loadImageFailed", "transformChange"] }, { type: i3.NbTagListComponent, selector: "nb-tag-list", inputs: ["size", "tabIndex", "role", "multiple"], outputs: ["tagRemove"], exportAs: ["nbTagList"] }, { type: i3.NbTagComponent, selector: "nb-tag", inputs: ["appearance", "status", "size", "role", "selected", "removable", "text"], outputs: ["remove", "selectedChange"], exportAs: ["nbTag"] }, { type: i3.NbAutocompleteComponent, selector: "nb-autocomplete", inputs: ["size", "activeFirst", "handleDisplayFn", "optionsListClass", "optionsPanelClass"], outputs: ["selectedChange"] }], directives: [{ type: i6.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i7.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { type: i7.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { type: i7.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { type: i7.NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]" }, { type: i3.NbDatepickerDirective, selector: "input[nbDatepicker]", inputs: ["nbDatepicker"] }, { type: i3.NbInputDirective, selector: "input[nbInput],textarea[nbInput]", inputs: ["fieldSize", "status", "shape", "fullWidth"] }, { type: i3.NbTimePickerDirective, selector: "input[nbTimepicker]", inputs: ["overlayOffset", "nbTimepicker"] }, { type: i6.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i3.NbTagInputDirective, selector: "input[nbTagInput]", inputs: ["separatorKeys"], outputs: ["tagAdd"], exportAs: ["nbTagInput"] }, { type: i3.NbAutocompleteDirective, selector: "input[nbAutocomplete]", inputs: ["overlayOffset", "scrollStrategy", "nbAutocomplete", "focusInputOnValueChange", "customOverlayHost"] }], pipes: { "async": i6.AsyncPipe } });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.5", ngImport: i0, type: RestResourceEditorFieldsComponent, decorators: [{
            type: Component,
            args: [{
                    selector: "input-editor",
                    templateUrl: "./rest-resource-editor-fields.component.html",
                    styleUrls: ["./rest-resource-editor-fields.component.scss"],
                }]
        }], ctorParameters: function () { return [{ type: i1.RestAdminConfigService }, { type: i2.RestResourceService }]; }, propDecorators: { input: [{
                type: ViewChild,
                args: ["autoInput"]
            }], inputBelongTo: [{
                type: ViewChild,
                args: ["autoInputBelongToMany"]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzdC1yZXNvdXJjZS1lZGl0b3ItZmllbGRzLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3Jlc3QtYWRtaW4vc3JjL2xpYi9yZXN0LWFkbWluL3Jlc3QtcmVzb3VyY2UvY29tcG9uZW50cy9yZXN0LXJlc291cmNlLWVkaXRvci1maWVsZHMvcmVzdC1yZXNvdXJjZS1lZGl0b3ItZmllbGRzLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3Jlc3QtYWRtaW4vc3JjL2xpYi9yZXN0LWFkbWluL3Jlc3QtcmVzb3VyY2UvY29tcG9uZW50cy9yZXN0LXJlc291cmNlLWVkaXRvci1maWVsZHMvcmVzdC1yZXNvdXJjZS1lZGl0b3ItZmllbGRzLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQWlCLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNwRSxPQUFPLEVBQ0wsaUJBQWlCLEVBQ2pCLG9CQUFvQixHQUNyQixNQUFNLHdCQUF3QixDQUFDO0FBRWhDLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNoRCxPQUFPLEVBQUUsZUFBZSxFQUFjLEVBQUUsRUFBZ0IsTUFBTSxNQUFNLENBQUM7QUFDckUsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBYSxnQkFBZ0IsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBRy9FLE9BQU8sRUFBcUIsWUFBWSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFFcEUsT0FBTyxLQUFLLENBQUMsTUFBTSxRQUFRLENBQUM7Ozs7Ozs7OztBQU01QixNQUFNLE9BQU8saUNBQWtDLFNBQVEsYUFBYTtJQWlCbEUsWUFDVSxzQkFBOEMsRUFDOUMsa0JBQXVDO1FBRS9DLEtBQUssRUFBRSxDQUFD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QUNILElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQUVELGtCQUFrQjtJQUVsQixRQUFRLENBQUMsTUFBTSxFQUFFLEtBQUs7UUFDcEIsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztJQUM5QixDQUFDOzs4SEEzUFUsaUNBQWlDO2tIQUFqQyxpQ0FBaUMsd1JDcEI5QyxtL1RBOFNBOzJGRDFSYSxpQ0FBaUM7a0JBTDdDLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLGNBQWM7b0JBQ3hCLFdBQVcsRUFBRSw4Q0FBOEM7b0JBQzNELFNBQVMsRUFBRSxDQUFDLDhDQUE4QyxDQUFDO2lCQUM1RDsrSUFleUIsS0FBSztzQkFBNUIsU0FBUzt1QkFBQyxXQUFXO2dCQUNjLGFBQWE7c0JBQWhELFNBQVM7dUJBQUMsdUJBQXVCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25Jbml0LCBWaWV3Q2hpbGQgfSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHtcbiAgRmlsZVVwbG9hZENvbnRyb2wsXG4gIEZpbGVVcGxvYWRWYWxpZGF0b3JzLFxufSBmcm9tIFwiQGlwbGFiL25neC1maWxlLXVwbG9hZFwiO1xuaW1wb3J0IHsgTmJUYWdDb21wb25lbnQsIE5iVGFnSW5wdXRBZGRFdmVudCB9IGZyb20gXCJAbmVidWxhci90aGVtZVwiO1xuaW1wb3J0IHsgRGVmYXVsdEVkaXRvciB9IGZyb20gXCJuZzItc21hcnQtdGFibGVcIjtcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSwgb2YsIFN1YnNjcmlwdGlvbiB9IGZyb20gXCJyeGpzXCI7XG5pbXBvcnQgeyBtYXAgfSBmcm9tIFwicnhqcy9vcGVyYXRvcnNcIjtcbmltcG9ydCB7IFJlc3RGaWVsZCwgUkVTVF9GSUVMRF9UWVBFUyB9IGZyb20gXCIuLi8uLi9tb2RlbHMvcmVzdC1yZXNvdXJjZS5tb2RlbFwiO1xuaW1wb3J0IHsgUmVzdEFkbWluQ29uZmlnU2VydmljZSB9IGZyb20gXCIuLi8uLi9zZXJ2aWNlL3Jlc3QtYWRtaW4tY29uZmlnLnNlcnZpY2VcIjtcbmltcG9ydCB7IFJlc3RSZXNvdXJjZVNlcnZpY2UgfSBmcm9tIFwiLi4vLi4vc2VydmljZS9yZXN0LXJlc291cmNlLnNlcnZpY2VcIjtcbmltcG9ydCB7IEltYWdlQ3JvcHBlZEV2ZW50LCBiYXNlNjRUb0ZpbGUgfSBmcm9tIFwibmd4LWltYWdlLWNyb3BwZXJcIjtcblxuaW1wb3J0ICogYXMgXyBmcm9tIFwibG9kYXNoXCI7XG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6IFwiaW5wdXQtZWRpdG9yXCIsXG4gIHRlbXBsYXRlVXJsOiBcIi4vcmVzdC1yZXNvdXJjZS1lZGl0b3ItZmllbGRzLmNvbXBvbmVudC5odG1sXCIsXG4gIHN0eWxlVXJsczogW1wiLi9yZXN0LXJlc291cmNlLWVkaXRvci1maWVsZHMuY29tcG9uZW50LnNjc3NcIl0sXG59KVxuZXhwb3J0IGNsYXNzIFJlc3RSZXNvdXJjZUVkaXRvckZpZWxkc0NvbXBvbmVudCBleHRlbmRzIERlZmF1bHRFZGl0b3Ige1xuICBpbmZvUm93czogYW55O1xuXG4gIGZpZWxkOiBSZXN0RmllbGQ7XG4gIG9wdGlvbnM6IGFueVtdO1xuICBmaWx0ZXJlZE9wdGlvbnMkOiBPYnNlcnZhYmxlPHN0cmluZ1tdPjtcblxuICAvLyBUZXN0XG4gIHB1YmxpYyByZWFkb25seSB1cGxvYWRlZEZpbGU6IEJlaGF2aW9yU3ViamVjdDxzdHJpbmc+ID0gbmV3IEJlaGF2aW9yU3ViamVjdChcbiAgICBudWxsXG4gICk7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb247XG4gIC8vIEVuZCB0ZXN0XG5cbiAgQFZpZXdDaGlsZChcImF1dG9JbnB1dFwiKSBpbnB1dDtcbiAgQFZpZXdDaGlsZChcImF1dG9JbnB1dEJlbG9uZ1RvTWFueVwiKSBpbnB1dEJlbG9uZ1RvO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgc2VydmljZVJlc3RBZG1pbkNvbmZpZzogUmVzdEFkbWluQ29uZmlnU2VydmljZSxcbiAgICBwcml2YXRlIHNlcnZpY2VSZXNSZXNvdXJjZTogUmVzdFJlc291cmNlU2VydmljZVxuICApIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgLy8gQ29udHJvbCBzdXIgbGVzIGZpY2hpZXJzIGEgdXBsb2FkXG4gIHB1YmxpYyByZWFkb25seSBjb250cm9sID0gbmV3IEZpbGVVcGxvYWRDb250cm9sKFxuICAgIHtcbiAgICAgIGxpc3RWaXNpYmxlOiB0cnVlLFxuICAgICAgYWNjZXB0OiBbXCJpbWFnZS8qXCJdLFxuICAgICAgZGlzY2FyZEludmFsaWQ6IHRydWUsXG4gICAgICBtdWx0aXBsZTogZmFsc2UsXG4gICAgfSxcbiAgICBbXG4gICAgICBGaWxlVXBsb2FkVmFsaWRhdG9ycy5hY2NlcHQoW1wiaW1hZ2UvKlwiXSksXG4gICAgICBGaWxlVXBsb2FkVmFsaWRhdG9ycy5maWxlc0xpbWl0KDEpLFxuICAgIF1cbiAgKTtcblxuICBjb250cm9sQ3JvcGVyID0gbnVsbDtcbiAgY3JvcHBlZEltYWdlOiBhbnkgPSBcIlwiO1xuICBpc0Nyb3AgPSBmYWxzZTtcblxuICAvLyBFbmQgdGVzdFxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IHRoaXMuY29udHJvbC52YWx1ZUNoYW5nZXMuc3Vic2NyaWJlKFxuICAgICAgKHZhbHVlczogQXJyYXk8RmlsZT4pID0+IHtcbiAgICAgICAgdGhpcy5nZXRJbWFnZSh2YWx1ZXNbMF0pO1xuICAgICAgICB0aGlzLmNvbnRyb2xDcm9wZXIgPSB2YWx1ZXNbMF07XG4gICAgICB9XG4gICAgKTtcbiAgICBcbiAgICB0aGlzLmluZm9Sb3dzID0gdGhpcy5jZWxsLmdldENvbHVtbigpLnZhbHVlUHJlcGFyZUZ1bmN0aW9uKCk7XG4gICAgdGhpcy5maWVsZCA9IHRoaXMuaW5mb1Jvd3MucmVzdEZpZWxkO1xuXG4gICAgc3dpdGNoICh0aGlzLmZpZWxkLnR5cGUpIHtcbiAgICAgIGNhc2UgUkVTVF9GSUVMRF9UWVBFUy5IQVNfTUFOWTpcbiAgICAgICAgdGhpcy5jZWxsLm5ld1ZhbHVlID0gbmV3IFNldChbXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSRVNUX0ZJRUxEX1RZUEVTLkJFTE9OR19UTzpcbiAgICAgICAgY29uc3QgcmVzdFJlc291cmNlID0gdGhpcy5zZXJ2aWNlUmVzdEFkbWluQ29uZmlnLmdldFNwZWNpZmljUmVzb3VyY2UoXG4gICAgICAgICAgdGhpcy5maWVsZC5tZXRhRGF0YS5hZGRDb25maWcuYmVsb25nVG9PcHRpb25zLnJlc291cmNlTmFtZVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnNlcnZpY2VSZXNSZXNvdXJjZVxuICAgICAgICAgIC5nZXRSZXNvdXJjZXMoe1xuICAgICAgICAgICAgYXBpOiByZXN0UmVzb3VyY2UuYXBpLFxuICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHRoaXMuZmllbGQubWV0YURhdGEuYWRkQ29uZmlnLmJlbG9uZ1RvT3B0aW9uc1xuICAgICAgICAgICAgICAucXVlcnlQYXJhbXNcbiAgICAgICAgICAgICAgPyB0aGlzLmZpZWxkLm1ldGFEYXRhLmFkZENvbmZpZy5iZWxvbmdUb09wdGlvbnMucXVlcnlQYXJhbXNcbiAgICAgICAgICAgICAgOiByZXN0UmVzb3VyY2UucXVlcnlQYXJhbXMsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuc3Vic2NyaWJlKChyZXNwb25zZTogYW55KSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSByZXNwb25zZTtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRPcHRpb25zJCA9IG9mKHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUkVTVF9GSUVMRF9UWVBFUy5CRUxPTkdfVE9fTUFOWTpcbiAgICAgICAgdGhpcy5jZWxsLm5ld1ZhbHVlID0gbmV3IFNldChbXSk7XG5cbiAgICAgICAgY29uc3QgcmVzb3VyY2UgPSB0aGlzLnNlcnZpY2VSZXN0QWRtaW5Db25maWcuZ2V0U3BlY2lmaWNSZXNvdXJjZShcbiAgICAgICAgICB0aGlzLmZpZWxkLm1ldGFEYXRhLmFkZENvbmZpZy5iZWxvbmdUb01hbnlPcHRpb25zLnJlbGF0ZWROYW1lXG4gICAgICAgICk7XG4gICAgICAgIHRoaXMuc2VydmljZVJlc1Jlc291cmNlXG4gICAgICAgICAgLmdldFJlc291cmNlcyh7XG4gICAgICAgICAgICBhcGk6IHJlc291cmNlLmFwaSxcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiB0aGlzLmZpZWxkLm1ldGFEYXRhLmFkZENvbmZpZy5iZWxvbmdUb01hbnlPcHRpb25zXG4gICAgICAgICAgICAgIC5xdWVyeVBhcmFtc1xuICAgICAgICAgICAgICA/IHRoaXMuZmllbGQubWV0YURhdGEuYWRkQ29uZmlnLmJlbG9uZ1RvTWFueU9wdGlvbnMucXVlcnlQYXJhbXNcbiAgICAgICAgICAgICAgOiByZXNvdXJjZS5xdWVyeVBhcmFtcyxcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5zdWJzY3JpYmUoKHJlc3BvbnNlOiBhbnkpID0+IHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJlZE9wdGlvbnMkID0gb2YodGhpcy5vcHRpb25zKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJFU1RfRklFTERfVFlQRVMuSU1BR0U6XG4gICAgICBjYXNlIFJFU1RfRklFTERfVFlQRVMuRklMRTpcbiAgICAgICAgdGhpcy5jZWxsLm5ld1ZhbHVlID0gW107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSRVNUX0ZJRUxEX1RZUEVTLkJPT0xFQU46XG4gICAgICAgIHRoaXMuY2VsbC5uZXdWYWx1ZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIGNhc2UgUkVTVF9GSUVMRF9UWVBFUy5QREY6XG4gICAgICAvLyB0aGlzLmNlbGwubmV3VmFsdWUgPSBbXTtcbiAgICAgIC8vIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBnZXQgUkVTVF9GSUVMRF9UWVBFUygpIHtcbiAgICByZXR1cm4gUkVTVF9GSUVMRF9UWVBFUztcbiAgfVxuXG4gIC8vIFRhZ3NcbiAgb25UYWdSZW1vdmUodGFnVG9SZW1vdmU6IE5iVGFnQ29tcG9uZW50KTogdm9pZCB7XG4gICAgY29uc3QgdHJlZXNBID0gbmV3IFNldCh0aGlzLmNlbGwubmV3VmFsdWUpO1xuXG4gICAgdHJlZXNBLmRlbGV0ZSh0YWdUb1JlbW92ZS50ZXh0KTtcblxuICAgIHRoaXMuY2VsbC5uZXdWYWx1ZSA9IEFycmF5LmZyb20odHJlZXNBLnZhbHVlcygpKTtcbiAgfVxuXG4gIG9uVGFnQWRkKHsgdmFsdWUsIGlucHV0IH06IE5iVGFnSW5wdXRBZGRFdmVudCk6IHZvaWQge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgY29uc3QgdHJlZXNBID0gbmV3IFNldCh0aGlzLmNlbGwubmV3VmFsdWUpO1xuICAgICAgdHJlZXNBLmFkZCh2YWx1ZSk7XG5cbiAgICAgIHRoaXMuY2VsbC5uZXdWYWx1ZSA9IEFycmF5LmZyb20odHJlZXNBLnZhbHVlcygpKTtcbiAgICB9XG4gICAgaW5wdXQubmF0aXZlRWxlbWVudC52YWx1ZSA9IFwiXCI7XG4gIH1cblxuICAvLyBFbmQgdGFnXG5cbiAgLy8gQXV0b2NvbXBsZXRlXG4gIHByaXZhdGUgZmlsdGVyKHZhbHVlOiBhbnkpOiBzdHJpbmdbXSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZpbHRlcigob3B0aW9uVmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmllbGQubWV0YURhdGEuYWRkQ29uZmlnLmJlbG9uZ1RvT3B0aW9ucy5maWx0ZXJLZXlzLnNvbWUoXG4gICAgICAgICAgKGVsdCkgPT5cbiAgICAgICAgICAgIGAke29wdGlvblZhbHVlW2VsdF0udG9Mb3dlckNhc2UoKX1gLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBgJHt2YWx1ZS50b0xvd2VyQ2FzZSgpfWBcbiAgICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGdldEZpbHRlcmVkT3B0aW9ucyh2YWx1ZTogYW55KTogT2JzZXJ2YWJsZTxzdHJpbmdbXT4ge1xuICAgIHJldHVybiBvZih2YWx1ZSkucGlwZShcbiAgICAgIG1hcCgoZmlsdGVyU3RyaW5nOiBzdHJpbmcpID0+IHRoaXMuZmlsdGVyKGZpbHRlclN0cmluZykpXG4gICAgKTtcbiAgfVxuXG4gIG9uQ2hhbmdlKCkge1xuICAgIHRoaXMuZmlsdGVyZWRPcHRpb25zJCA9IHRoaXMuZ2V0RmlsdGVyZWRPcHRpb25zKFxuICAgICAgdGhpcy5pbnB1dC5uYXRpdmVFbGVtZW50LnZhbHVlXG4gICAgKTtcbiAgfVxuXG4gIG9uU2VsZWN0aW9uQ2hhbmdlKCRldmVudCkge1xuICAgIHRoaXMuZmlsdGVyZWRPcHRpb25zJCA9IHRoaXMuZ2V0RmlsdGVyZWRPcHRpb25zKCRldmVudCk7XG4gIH1cblxuICAvLyBFbmQgQXV0b2NvbXBsZXRlXG5cbiAgcHVibGljIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICBnZXRJbWFnZShmaWxlOiBGaWxlKTogdm9pZCB7XG4gICAgaWYgKEZpbGVSZWFkZXIgJiYgZmlsZSkge1xuICAgICAgY29uc3QgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZnIub25sb2FkID0gKGU6IGFueSkgPT4ge1xuICAgICAgICB0aGlzLnVwbG9hZGVkRmlsZS5uZXh0KGUudGFyZ2V0LnJlc3VsdCk7XG4gICAgICB9O1xuICAgICAgZnIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGxvYWRlZEZpbGUubmV4dChudWxsKTtcbiAgICB9XG4gIH1cblxuICBpbWFnZUNyb3BwZWQoZXZlbnQ6IEltYWdlQ3JvcHBlZEV2ZW50KSB7XG4gICAgdGhpcy5jcm9wcGVkSW1hZ2UgPSBldmVudC5iYXNlNjQ7XG4gIH1cblxuICBhY3RpdmVDcm9wZXIoKSB7XG4gICAgdGhpcy5pc0Nyb3AgPSB0cnVlO1xuICB9XG5cbiAgc2F2ZUNyb3BlcigpIHtcbiAgICB0aGlzLmlzQ3JvcCA9IGZhbHNlO1xuICAgIHRoaXMudXBsb2FkZWRGaWxlLm5leHQodGhpcy5jcm9wcGVkSW1hZ2UpO1xuICAgIHRoaXMuY2VsbC5zZXRWYWx1ZShiYXNlNjRUb0ZpbGUodGhpcy5jcm9wcGVkSW1hZ2UpKTtcbiAgfVxuXG4gIC8vYmVsb25nVG9NYW55T3B0aW9uc1xuICBvbkNob29zZShldmVudCkge1xuICAgIGNvbnN0IGNlbGxEYXRhID0gQXJyYXkuZnJvbSh0aGlzLmNlbGwubmV3VmFsdWUudmFsdWVzKCkpO1xuICAgIGlmIChldmVudCkge1xuICAgICAgY29uc3Qgc2VhcmNoID0gY2VsbERhdGEuZmluZCgoZWx0OiBhbnkpID0+IGVsdC5pZCA9PSBldmVudC5pZCk7XG4gICAgICBpZiAoc2VhcmNoID09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBuZXdFbHQgPSB7XG4gICAgICAgICAgaWQ6IGV2ZW50LmlkLFxuICAgICAgICAgIFt0aGlzLmZpZWxkLm1ldGFEYXRhLmFkZENvbmZpZy5iZWxvbmdUb01hbnlPcHRpb25zLnJlbGF0ZWRJZE5hbWVdOlxuICAgICAgICAgICAgZXZlbnQuaWQsXG4gICAgICAgICAgW3RoaXMuZmllbGQubWV0YURhdGEuYWRkQ29uZmlnLmJlbG9uZ1RvTWFueU9wdGlvbnMucmVzb3VyY2VJZE5hbWVdOlxuICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICBbdGhpcy5maWVsZC5tZXRhRGF0YS5hZGRDb25maWcuYmVsb25nVG9NYW55T3B0aW9ucy5maWx0ZXJLZXlzWzBdXTpcbiAgICAgICAgICAgIGV2ZW50W1xuICAgICAgICAgICAgICB0aGlzLmZpZWxkLm1ldGFEYXRhLmFkZENvbmZpZy5iZWxvbmdUb01hbnlPcHRpb25zLmZpbHRlcktleXNbMF1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgc2F2ZVJlbGF0ZWRJZE5hbWU6XG4gICAgICAgICAgICB0aGlzLmZpZWxkLm1ldGFEYXRhLmFkZENvbmZpZy5iZWxvbmdUb01hbnlPcHRpb25zLnJlbGF0ZWRJZE5hbWUsXG4gICAgICAgICAgc2F2ZVJlc291cmNlSWROYW1lOlxuICAgICAgICAgICAgdGhpcy5maWVsZC5tZXRhRGF0YS5hZGRDb25maWcuYmVsb25nVG9NYW55T3B0aW9ucy5yZXNvdXJjZUlkTmFtZSxcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCB0cmVlc0EgPSBuZXcgU2V0KHRoaXMuY2VsbC5uZXdWYWx1ZSk7XG4gICAgICAgIHRyZWVzQS5hZGQobmV3RWx0KTtcblxuICAgICAgICB0aGlzLmNlbGwubmV3VmFsdWUgPSBBcnJheS5mcm9tKHRyZWVzQS52YWx1ZXMoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaW5wdXRCZWxvbmdUby5uYXRpdmVFbGVtZW50LnZhbHVlID0gXCJcIjtcbiAgfVxuXG4gIG9uVGFnUmVtb3ZlQmVsb25nKHRhZ1RvUmVtb3ZlOiBOYlRhZ0NvbXBvbmVudCk6IHZvaWQge1xuICAgIGNvbnN0IGNlbGxEYXRhID0gQXJyYXkuZnJvbSh0aGlzLmNlbGwubmV3VmFsdWUudmFsdWVzKCkpO1xuICAgIGNvbnN0IHNhdmUgPSBbXTtcblxuICAgIGNlbGxEYXRhLmZvckVhY2goKGVsdCkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBlbHRbXG4gICAgICAgICAgdGhpcy5maWVsZC5tZXRhRGF0YS5hZGRDb25maWcuYmVsb25nVG9NYW55T3B0aW9ucy50ZW1wbGF0ZVxuICAgICAgICAgICAgPyB0aGlzLmZpZWxkLm1ldGFEYXRhLmFkZENvbmZpZy5iZWxvbmdUb01hbnlPcHRpb25zLnRlbXBsYXRlXG4gICAgICAgICAgICA6IHRoaXMuZmllbGQubWV0YURhdGEuYWRkQ29uZmlnLmJlbG9uZ1RvTWFueU9wdGlvbnMuZmlsdGVyS2V5c1swXVxuICAgICAgICBdLmxvY2FsZUNvbXBhcmUodGFnVG9SZW1vdmUudGV4dCkgIT0gMFxuICAgICAgKVxuICAgICAgICBzYXZlLnB1c2goZWx0KTtcbiAgICB9KTtcbiAgICB0aGlzLmNlbGwubmV3VmFsdWUgPSBBcnJheS5mcm9tKHNhdmUpO1xuICB9XG5cbiAgLy9FbmQgQmVsb25nVG9NYW55XG5cbiAgZ2V0RmllbGQoZmllbGRzLCB2YWx1ZSkge1xuICAgIHJldHVybiBfLmdldChmaWVsZHMsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZGNvbmZpZzogY2hhbXBzIHBhciBsZXF1ZWwgb24gdmEgZmlsdHJlcixcbiAqIGxhIHZhbGV1ciBhIHJldGVuaXIgZXQgbGUgdGVtcGxhdGUgYSBhZmZpY2hlclxuICovXG4iLCI8bmctY29udGFpbmVyICpuZ0lmPVwiZmllbGQuaW5Gb3JtID09IHRydWVcIj5cbiAgPCEtLSBJbnB1dCB0eXBlIHN0cmluZyAtLT5cbiAgPGlucHV0XG4gICAgdHlwZT1cInRleHRcIlxuICAgICpuZ0lmPVwiZmllbGQudHlwZSA9PSBSRVNUX0ZJRUxEX1RZUEVTLlNUUklOR1wiXG4gICAgWyhuZ01vZGVsKV09XCJjZWxsLm5ld1ZhbHVlXCJcbiAgICBbbmFtZV09XCJjZWxsLmdldElkKClcIlxuICAgIFtwbGFjZWhvbGRlcl09XCJjZWxsLmdldFRpdGxlKClcIlxuICAgIFtkaXNhYmxlZF09XCIhY2VsbC5pc0VkaXRhYmxlKClcIlxuICAgIChjbGljayk9XCJvbkNsaWNrLmVtaXQoJGV2ZW50KVwiXG4gICAgKGtleWRvd24uZW50ZXIpPVwib25FZGl0ZWQuZW1pdCgkZXZlbnQpXCJcbiAgICAoa2V5ZG93bi5lc2MpPVwib25TdG9wRWRpdGluZy5lbWl0KClcIlxuICAgIGNsYXNzPVwiZm9ybS1jb250cm9sIG5nLXZhbGlkIG5nLXRvdWNoZWQgbmctZGlydHlcIlxuICAgIGZ1bGxXaWR0aFxuICAvPlxuXG4gIDwhLS0gSW5wdXQgdHlwZSB0ZXh0IC0tPlxuICA8dGV4dGFyZWFcbiAgICBbKG5nTW9kZWwpXT1cImNlbGwubmV3VmFsdWVcIlxuICAgIFtuYW1lXT1cImNlbGwuZ2V0SWQoKVwiXG4gICAgW3BsYWNlaG9sZGVyXT1cImNlbGwuZ2V0VGl0bGUoKVwiXG4gICAgW2Rpc2FibGVkXT1cIiFjZWxsLmlzRWRpdGFibGUoKVwiXG4gICAgKGNsaWNrKT1cIm9uQ2xpY2suZW1pdCgkZXZlbnQpXCJcbiAgICAoa2V5ZG93bi5lbnRlcik9XCJvbkVkaXRlZC5lbWl0KCRldmVudClcIlxuICAgIChrZXlkb3duLmVzYyk9XCJvblN0b3BFZGl0aW5nLmVtaXQoKVwiXG4gICAgY2xhc3M9XCJmb3JtLWNvbnRyb2wgbmctdmFsaWQgbmctdG91Y2hlZCBuZy1kaXJ0eVwiXG4gICAgKm5nSWY9XCJmaWVsZC50eXBlID09IFJFU1RfRklFTERfVFlQRVMuVEVYVFwiXG4gICAgZnVsbFdpZHRoXG4gID48L3RleHRhcmVhPlxuXG4gIDwhLS0gSW5wdXQgdHlwZSBudW1iZXIgIC0tPlxuICA8aW5wdXRcbiAgICBbKG5nTW9kZWwpXT1cImNlbGwubmV3VmFsdWVcIlxuICAgIFtuYW1lXT1cImNlbGwuZ2V0SWQoKVwiXG4gICAgW3BsYWNlaG9sZGVyXT1cImNlbGwuZ2V0VGl0bGUoKVwiXG4gICAgW2Rpc2FibGVkXT1cIiFjZWxsLmlzRWRpdGFibGUoKVwiXG4gICAgKGNsaWNrKT1cIm9uQ2xpY2suZW1pdCgkZXZlbnQpXCJcbiAgICAoa2V5ZG93bi5lbnRlcik9XCJvbkVkaXRlZC5lbWl0KCRldmVudClcIlxuICAgIChrZXlkb3duLmVzYyk9XCJvblN0b3BFZGl0aW5nLmVtaXQoKVwiXG4gICAgY2xhc3M9XCJmb3JtLWNvbnRyb2wgbmctdmFsaWQgbmctdG91Y2hlZCBuZy1kaXJ0eVwiXG4gICAgdHlwZT1cIm51bWJlclwiXG4gICAgZnVsbFdpZHRoXG4gICAgKm5nSWY9XCJmaWVsZC50eXBlID09IFJFU1RfRklFTERfVFlQRVMuTlVNQkVSXCJcbiAgLz5cblxuICA8IS0tIElucHV0IHR5cGUgZGF0ZSAtLT5cbiAgPGlucHV0XG4gICAgKm5nSWY9XCJmaWVsZC50eXBlID09IFJFU1RfRklFTERfVFlQRVMuREFURVwiXG4gICAgW25iRGF0ZXBpY2tlcl09XCJmb3JtcGlja2VyXCJcbiAgICBbKG5nTW9kZWwpXT1cImNlbGwubmV3VmFsdWVcIlxuICAgIFtuYW1lXT1cImNlbGwuZ2V0SWQoKVwiXG4gICAgW3BsYWNlaG9sZGVyXT1cImNlbGwuZ2V0VGl0bGUoKVwiXG4gICAgW2Rpc2FibGVkXT1cIiFjZWxsLmlzRWRpdGFibGUoKVwiXG4gICAgKGNsaWNrKT1cIm9uQ2xpY2suZW1pdCgkZXZlbnQpXCJcbiAgICAoa2V5ZG93bi5lbnRlcik9XCJvbkVkaXRlZC5lbWl0KCRldmVudClcIlxuICAgIChrZXlkb3duLmVzYyk9XCJvblN0b3BFZGl0aW5nLmVtaXQoKVwiXG4gICAgY2xhc3M9XCJmb3JtLWNvbnRyb2wgbmctdmFsaWQgbmctdG91Y2hlZCBuZy1kaXJ0eVwiXG4gICAgZnVsbFdpZHRoXG4gIC8+XG4gIDxuYi1kYXRlcGlja2VyICNmb3JtcGlja2VyPjwvbmItZGF0ZXBpY2tlcj5cblxuICA8IS0tIElucHV0IHR5cGUgZGF0ZVRpbWUgLS0+XG4gIDxuZy1jb250YWluZXIgKm5nSWY9XCJmaWVsZC50eXBlID09IFJFU1RfRklFTERfVFlQRVMuREFURVRJTUVcIj5cbiAgICA8aW5wdXRcbiAgICAgIG5iSW5wdXRcbiAgICAgIFtuYkRhdGVwaWNrZXJdPVwiZGF0ZVRpbWVQaWNrZXJcIlxuICAgICAgWyhuZ01vZGVsKV09XCJjZWxsLm5ld1ZhbHVlXCJcbiAgICAgIFtuYW1lXT1cImNlbGwuZ2V0SWQoKVwiXG4gICAgICBbcGxhY2Vob2xkZXJdPVwiY2VsbC5nZXRUaXRsZSgpXCJcbiAgICAgIFtkaXNhYmxlZF09XCIhY2VsbC5pc0VkaXRhYmxlKClcIlxuICAgICAgKGNsaWNrKT1cIm9uQ2xpY2suZW1pdCgkZXZlbnQpXCJcbiAgICAgIChrZXlkb3duLmVudGVyKT1cIm9uRWRpdGVkLmVtaXQoJGV2ZW50KVwiXG4gICAgICAoa2V5ZG93bi5lc2MpPVwib25TdG9wRWRpdGluZy5lbWl0KClcIlxuICAgICAgY2xhc3M9XCJmb3JtLWNvbnRyb2wgbmctdmFsaWQgbmctdG91Y2hlZCBuZy1kaXJ0eVwiXG4gICAgICBmdWxsV2lkdGhcbiAgICAvPlxuICAgIDxuYi1kYXRlLXRpbWVwaWNrZXIgd2l0aFNlY29uZHMgI2RhdGVUaW1lUGlja2VyPjwvbmItZGF0ZS10aW1lcGlja2VyPlxuICA8L25nLWNvbnRhaW5lcj5cblxuICA8IS0tIElucHV0IHR5cGUgdGltZSAtLT5cbiAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImZpZWxkLnR5cGUgPT0gUkVTVF9GSUVMRF9UWVBFUy5USU1FXCI+XG4gICAgPGlucHV0XG4gICAgICBbbmJUaW1lcGlja2VyXT1cInRpbWVwaWNrZXJcIlxuICAgICAgdHdlbHZlSG91cnNGb3JtYXRdXG4gICAgICBuYklucHV0XG4gICAgICBbKG5nTW9kZWwpXT1cImNlbGwubmV3VmFsdWVcIlxuICAgICAgW25hbWVdPVwiY2VsbC5nZXRJZCgpXCJcbiAgICAgIFtwbGFjZWhvbGRlcl09XCJjZWxsLmdldFRpdGxlKClcIlxuICAgICAgW2Rpc2FibGVkXT1cIiFjZWxsLmlzRWRpdGFibGUoKVwiXG4gICAgICAoY2xpY2spPVwib25DbGljay5lbWl0KCRldmVudClcIlxuICAgICAgKGtleWRvd24uZW50ZXIpPVwib25FZGl0ZWQuZW1pdCgkZXZlbnQpXCJcbiAgICAgIChrZXlkb3duLmVzYyk9XCJvblN0b3BFZGl0aW5nLmVtaXQoKVwiXG4gICAgICBjbGFzcz1cImZvcm0tY29udHJvbCBuZy12YWxpZCBuZy10b3VjaGVkIG5nLWRpcnR5XCJcbiAgICAgIGZ1bGxXaWR0aFxuICAgIC8+XG4gICAgPG5iLXRpbWVwaWNrZXIgI3RpbWVwaWNrZXI+PC9uYi10aW1lcGlja2VyPlxuICA8L25nLWNvbnRhaW5lcj5cblxuICA8IS0tIElucHV0IHR5cGUgZW51bSAtLT5cbiAgPG5iLXNlbGVjdFxuICAgIFsobmdNb2RlbCldPVwiY2VsbC5uZXdWYWx1ZVwiXG4gICAgW25hbWVdPVwiY2VsbC5nZXRJZCgpXCJcbiAgICAoY2hhbmdlKT1cIm9uQ2xpY2suZW1pdCgkZXZlbnQpXCJcbiAgICBjbGFzcz1cImlucHV0LXNwYWNlXCJcbiAgICAqbmdJZj1cImZpZWxkLnR5cGUgPT0gUkVTVF9GSUVMRF9UWVBFUy5FTlVNXCJcbiAgICBuYklucHV0XG4gID5cbiAgICA8bmItb3B0aW9uXG4gICAgICAqbmdGb3I9XCJsZXQgb3B0aW9uIG9mIGZpZWxkLm1ldGFEYXRhLmFkZENvbmZpZy5lbnVtT3B0aW9uc1wiXG4gICAgICBbdmFsdWVdPVwib3B0aW9uLnZhbHVlXCJcbiAgICAgID57eyBvcHRpb24ubGFiZWwgfX08L25iLW9wdGlvblxuICAgID5cbiAgPC9uYi1zZWxlY3Q+XG5cbiAgPCEtLSBJbnB1dCB0eXBlIEJvb2xlYW4gLS0+XG4gIDxkaXZcbiAgICBzdHlsZT1cInRleHQtYWxpZ246IGNlbnRlclwiXG4gICAgKm5nSWY9XCJmaWVsZC50eXBlID09IFJFU1RfRklFTERfVFlQRVMuQk9PTEVBTlwiXG4gID5cbiAgICA8bmItdG9nZ2xlIFtuYW1lXT1cImNlbGwuZ2V0SWQoKVwiIFsobmdNb2RlbCldPVwiY2VsbC5uZXdWYWx1ZVwiPjwvbmItdG9nZ2xlPlxuICA8L2Rpdj5cblxuICA8bmctY29udGFpbmVyICpuZ0lmPVwiZmllbGQudHlwZSA9PSBSRVNUX0ZJRUxEX1RZUEVTLkZJTEVcIj5cbiAgICA8ZmlsZS11cGxvYWRcbiAgICAgIFsobmdNb2RlbCldPVwiY2VsbC5uZXdWYWx1ZVwiXG4gICAgICBjbGFzcz1cImlucHV0LXNwYWNlXCJcbiAgICAgIFtuYW1lXT1cImZpZWxkLmxhYmVsXCJcbiAgICAgIHN0eWxlPVwibWluLXdpZHRoOiAzMDBweDsgbWF4LXdpZHRoOiAzMDBweFwiXG4gICAgPjwvZmlsZS11cGxvYWQ+XG4gIDwvbmctY29udGFpbmVyPlxuXG4gIDxuZy1jb250YWluZXIgKm5nSWY9XCJmaWVsZC50eXBlID09IFJFU1RfRklFTERfVFlQRVMuUERGXCI+XG4gICAgPGZpbGUtdXBsb2FkXG4gICAgICBbKG5nTW9kZWwpXT1cImNlbGwubmV3VmFsdWVcIlxuICAgICAgY2xhc3M9XCJpbnB1dC1zcGFjZVwiXG4gICAgICBbbmFtZV09XCJmaWVsZC5sYWJlbFwiXG4gICAgICBzdHlsZT1cIm1pbi13aWR0aDogMzAwcHg7IG1heC13aWR0aDogMzAwcHhcIlxuICAgID48L2ZpbGUtdXBsb2FkPlxuICAgIDxvYmplY3Qgd2lkdGg9XCIzMDBweFwiIGhlaWdodD1cIjMwMHB4XCIgW2RhdGFdPVwiY2VsbC5uZXdWYWx1ZVswXVwiPjwvb2JqZWN0PlxuICA8L25nLWNvbnRhaW5lcj5cblxuICA8bmctY29udGFpbmVyICpuZ0lmPVwiZmllbGQudHlwZSA9PSBSRVNUX0ZJRUxEX1RZUEVTLklNQUdFXCI+XG4gICAgPCEtLSBbKG5nTW9kZWwpXT1cImNlbGwubmV3VmFsdWVcIlxuICAgIGNsYXNzPVwiZmlsZS1pbWFnZVwiXG4gICAgW25hbWVdPVwiZmllbGQubGFiZWxcIiAtLT5cbiAgICA8ZmlsZS11cGxvYWRcbiAgICAgIFtjb250cm9sXT1cImNvbnRyb2xcIlxuICAgID5cbiAgICAgIDxuZy10ZW1wbGF0ZVxuICAgICAgICBsZXQtaXNGaWxlRHJhZ0Ryb3BBdmFpbGFibGU9XCJpc0ZpbGVEcmFnRHJvcEF2YWlsYWJsZVwiXG4gICAgICAgICNwbGFjZWhvbGRlclxuICAgICAgPlxuICAgICAgICA8ZGl2ICpuZ0lmPVwiY29udHJvbC5zaXplID09PSAwXCI+XG4gICAgICAgICAgPHN2ZyB2aWV3Qm94PVwiMCAwIDUxMiA1MTJcIiBjbGFzcz1cImljb25cIj5cbiAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgIGQ9XCJNMjk2IDM4NGgtODBjLTEzLjMgMC0yNC0xMC43LTI0LTI0VjE5MmgtODcuN2MtMTcuOCAwLTI2LjctMjEuNS0xNC4xLTM0LjFMMjQyLjMgNS43YzcuNS03LjUgMTkuOC03LjUgMjcuMyAwbDE1Mi4yIDE1Mi4yYzEyLjYgMTIuNiAzLjcgMzQuMS0xNC4xIDM0LjFIMzIwdjE2OGMwIDEzLjMtMTAuNyAyNC0yNCAyNHptMjE2LTh2MTEyYzAgMTMuMy0xMC43IDI0LTI0IDI0SDI0Yy0xMy4zIDAtMjQtMTAuNy0yNC0yNFYzNzZjMC0xMy4zIDEwLjctMjQgMjQtMjRoMTM2djhjMCAzMC45IDI1LjEgNTYgNTYgNTZoODBjMzAuOSAwIDU2LTI1LjEgNTYtNTZ2LThoMTM2YzEzLjMgMCAyNCAxMC43IDI0IDI0em0tMTI0IDg4YzAtMTEtOS0yMC0yMC0yMHMtMjAgOS0yMCAyMCA5IDIwIDIwIDIwIDIwLTkgMjAtMjB6bTY0IDBjMC0xMS05LTIwLTIwLTIwcy0yMCA5LTIwIDIwIDkgMjAgMjAgMjAgMjAtOSAyMC0yMHpcIlxuICAgICAgICAgICAgPjwvcGF0aD5cbiAgICAgICAgICA8L3N2Zz5cblxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJ1cGxvYWQtdGV4dFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgICAqbmdJZj1cImlzRmlsZURyYWdEcm9wQXZhaWxhYmxlOyBlbHNlIGlzTm90RHJhZ0Ryb3BBdmFpbGFibGVcIlxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICA8Yj5EcmFnIGFuZCBkcm9wPC9iPiBmaWxlczxiciAvPlxuICAgICAgICAgICAgICBvciBjbGljayBoZXJlXG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDxuZy10ZW1wbGF0ZSAjaXNOb3REcmFnRHJvcEF2YWlsYWJsZT5cbiAgICAgICAgICAgICAgPGI+Q2xpY2sgaGVyZTwvYj4gdG88YnIgLz5cbiAgICAgICAgICAgICAgY2hvb3NlIGEgZmlsZXNcbiAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgICAgPG5nLXRlbXBsYXRlIGxldC1pPVwiaW5kZXhcIiBsZXQtZmlsZT1cImZpbGVcIiBsZXQtY29udHJvbD1cImNvbnRyb2xcIiAjaXRlbT5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm92ZXJsYXlcIj5cbiAgICAgICAgICA8c3ZnXG4gICAgICAgICAgICB2aWV3Qm94PVwiMCAwIDQ0OCA1MTJcIlxuICAgICAgICAgICAgY2xhc3M9XCJkZWxldGUtYnV0dG9uXCJcbiAgICAgICAgICAgIChjbGljayk9XCJjb250cm9sLnJlbW92ZUZpbGUoZmlsZSlcIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIDxwYXRoXG4gICAgICAgICAgICAgIGQ9XCJNMzIgNDY0YTQ4IDQ4IDAgMCAwIDQ4IDQ4aDI4OGE0OCA0OCAwIDAgMCA0OC00OFYxMjhIMzJ6bTI3Mi0yNTZhMTYgMTYgMCAwIDEgMzIgMHYyMjRhMTYgMTYgMCAwIDEtMzIgMHptLTk2IDBhMTYgMTYgMCAwIDEgMzIgMHYyMjRhMTYgMTYgMCAwIDEtMzIgMHptLTk2IDBhMTYgMTYgMCAwIDEgMzIgMHYyMjRhMTYgMTYgMCAwIDEtMzIgMHpNNDMyIDMySDMxMmwtOS40LTE4LjdBMjQgMjQgMCAwIDAgMjgxLjEgMEgxNjYuOGEyMy43MiAyMy43MiAwIDAgMC0yMS40IDEzLjNMMTM2IDMySDE2QTE2IDE2IDAgMCAwIDAgNDh2MzJhMTYgMTYgMCAwIDAgMTYgMTZoNDE2YTE2IDE2IDAgMCAwIDE2LTE2VjQ4YTE2IDE2IDAgMCAwLTE2LTE2elwiXG4gICAgICAgICAgICA+PC9wYXRoPlxuICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgIDxpbWcgKm5nSWY9XCJjb250cm9sLnZhbGlkXCIgW3NyY109XCJ1cGxvYWRlZEZpbGUgfCBhc3luY1wiIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L2ZpbGUtdXBsb2FkPlxuXG4gICAgPGJ1dHRvblxuICAgICAgbmJCdXR0b25cbiAgICAgIHN0YXR1cz1cInByaW1hcnlcIlxuICAgICAgKm5nSWY9XCIhaXNDcm9wICYmIGNvbnRyb2xDcm9wZXIgIT0gbnVsbFwiXG4gICAgICAoY2xpY2spPVwiYWN0aXZlQ3JvcGVyKClcIlxuICAgID5cbiAgICAgIENST1BcbiAgICA8L2J1dHRvbj5cblxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJpc0Nyb3BcIj5cbiAgICAgIDxpbWFnZS1jcm9wcGVyXG4gICAgICAgIFtpbWFnZUZpbGVdPVwiY29udHJvbENyb3BlclwiXG4gICAgICAgIFttYWludGFpbkFzcGVjdFJhdGlvXT1cInRydWVcIlxuICAgICAgICBbYXNwZWN0UmF0aW9dPVwiNCAvIDNcIlxuICAgICAgICBmb3JtYXQ9XCJwbmdcIlxuICAgICAgICAoaW1hZ2VDcm9wcGVkKT1cImltYWdlQ3JvcHBlZCgkZXZlbnQpXCJcbiAgICAgID48L2ltYWdlLWNyb3BwZXI+XG5cbiAgICAgIDxidXR0b24gbmJCdXR0b24gc3RhdHVzPVwicHJpbWFyeVwiIChjbGljayk9XCJzYXZlQ3JvcGVyKClcIj5cbiAgICAgICAgU0FWRSBDSEFOR0VcbiAgICAgIDwvYnV0dG9uPlxuICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgPCEtLSA8aW1nIFtzcmNdPVwiY3JvcHBlZEltYWdlXCIgLz4gLS0+XG4gIDwvbmctY29udGFpbmVyPlxuXG4gIDwhLS0gSW5wdXQgdHlwZSAgLS0+XG4gIDxuZy1jb250YWluZXIgKm5nSWY9XCJmaWVsZC50eXBlID09IFJFU1RfRklFTERfVFlQRVMuSEFTX01BTllcIj5cbiAgICA8bmItdGFnLWxpc3QgKHRhZ1JlbW92ZSk9XCJvblRhZ1JlbW92ZSgkZXZlbnQpXCIgY2xhc3M9XCJpbnB1dC1zcGFjZVwiPlxuICAgICAgPG5iLXRhZ1xuICAgICAgICAqbmdGb3I9XCJsZXQgdHJlZSBvZiBjZWxsLm5ld1ZhbHVlXCJcbiAgICAgICAgW3RleHRdPVwidHJlZVwiXG4gICAgICAgIHJlbW92YWJsZVxuICAgICAgPjwvbmItdGFnPlxuICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgbmJUYWdJbnB1dCAodGFnQWRkKT1cIm9uVGFnQWRkKCRldmVudClcIiBmdWxsV2lkdGggLz5cbiAgICA8L25iLXRhZy1saXN0PlxuICA8L25nLWNvbnRhaW5lcj5cblxuICA8bmctY29udGFpbmVyICpuZ0lmPVwiZmllbGQudHlwZSA9PSBSRVNUX0ZJRUxEX1RZUEVTLkJFTE9OR19UT1wiPlxuICAgIDxpbnB1dFxuICAgICAgI2F1dG9JbnB1dFxuICAgICAgbmJJbnB1dFxuICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgKGlucHV0KT1cIm9uQ2hhbmdlKClcIlxuICAgICAgcGxhY2Vob2xkZXI9XCJFbnRlciB2YWx1ZVwiXG4gICAgICBbbmJBdXRvY29tcGxldGVdPVwiYXV0b1wiXG4gICAgICBbKG5nTW9kZWwpXT1cImNlbGwubmV3VmFsdWVcIlxuICAgIC8+XG5cbiAgICA8bmItYXV0b2NvbXBsZXRlICNhdXRvIChzZWxlY3RlZENoYW5nZSk9XCJvblNlbGVjdGlvbkNoYW5nZSgkZXZlbnQpXCI+XG4gICAgICA8bmItb3B0aW9uXG4gICAgICAgICpuZ0Zvcj1cImxldCBvcHRpb24gb2YgZmlsdGVyZWRPcHRpb25zJCB8IGFzeW5jXCJcbiAgICAgICAgW3ZhbHVlXT1cIlxuICAgICAgICAgIG9wdGlvbltcbiAgICAgICAgICAgIGZpZWxkPy5tZXRhRGF0YT8uYWRkQ29uZmlnLmJlbG9uZ1RvT3B0aW9ucz8udmFsdWVcbiAgICAgICAgICAgICAgPyBmaWVsZD8ubWV0YURhdGE/LmFkZENvbmZpZz8uYmVsb25nVG9PcHRpb25zPy52YWx1ZVxuICAgICAgICAgICAgICA6ICdpZCdcbiAgICAgICAgICBdXG4gICAgICAgIFwiXG4gICAgICA+XG4gICAgICAgIHt7XG4gICAgICAgICAgb3B0aW9uW1xuICAgICAgICAgICAgZmllbGQubWV0YURhdGEuYWRkQ29uZmlnLmJlbG9uZ1RvT3B0aW9ucy50ZW1wbGF0ZVxuICAgICAgICAgICAgICA/IGZpZWxkLm1ldGFEYXRhLmFkZENvbmZpZy5iZWxvbmdUb09wdGlvbnMudGVtcGxhdGVcbiAgICAgICAgICAgICAgOiBmaWVsZC5tZXRhRGF0YS5hZGRDb25maWcuYmVsb25nVG9PcHRpb25zLmZpbHRlcktleXNbMF1cbiAgICAgICAgICBdXG4gICAgICAgIH19XG4gICAgICA8L25iLW9wdGlvbj5cbiAgICA8L25iLWF1dG9jb21wbGV0ZT5cbiAgPC9uZy1jb250YWluZXI+XG5cbiAgPG5nLWNvbnRhaW5lciAqbmdJZj1cImZpZWxkLnR5cGUgPT0gUkVTVF9GSUVMRF9UWVBFUy5CRUxPTkdfVE9fTUFOWVwiPlxuICAgIDxkaXY+XG4gICAgICA8bmItdGFnLWxpc3QgKHRhZ1JlbW92ZSk9XCJvblRhZ1JlbW92ZUJlbG9uZygkZXZlbnQpXCIgY2xhc3M9XCJpbnB1dC1zcGFjZVwiPlxuICAgICAgICA8bmItdGFnXG4gICAgICAgICAgKm5nRm9yPVwibGV0IHRyZWUgb2YgY2VsbC5uZXdWYWx1ZVwiXG4gICAgICAgICAgW3RleHRdPVwiXG4gICAgICAgICAgICB0cmVlW1xuICAgICAgICAgICAgICBmaWVsZC5tZXRhRGF0YS5hZGRDb25maWcuYmVsb25nVG9NYW55T3B0aW9ucy50ZW1wbGF0ZVxuICAgICAgICAgICAgICAgID8gZmllbGQubWV0YURhdGEuYWRkQ29uZmlnLmJlbG9uZ1RvTWFueU9wdGlvbnMudGVtcGxhdGVcbiAgICAgICAgICAgICAgICA6IGZpZWxkLm1ldGFEYXRhLmFkZENvbmZpZy5iZWxvbmdUb01hbnlPcHRpb25zLmZpbHRlcktleXNbMF1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICBcIlxuICAgICAgICAgIHJlbW92YWJsZVxuICAgICAgICA+PC9uYi10YWc+XG4gICAgICAgIDxpbnB1dFxuICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICBuYlRhZ0lucHV0XG4gICAgICAgICAgI2F1dG9JbnB1dEJlbG9uZ1RvTWFueVxuICAgICAgICAgIFtuYkF1dG9jb21wbGV0ZV09XCJhdXRvQmVsb25Ub01hbnlcIlxuICAgICAgICAgICh0YWdBZGQpPVwib25UYWdBZGQoJGV2ZW50KVwiXG4gICAgICAgICAgZnVsbFdpZHRoXG4gICAgICAgIC8+XG5cbiAgICAgICAgPG5iLWF1dG9jb21wbGV0ZSAjYXV0b0JlbG9uVG9NYW55IChzZWxlY3RlZENoYW5nZSk9XCJvbkNob29zZSgkZXZlbnQpXCI+XG4gICAgICAgICAgPG5iLW9wdGlvblxuICAgICAgICAgICAgKm5nRm9yPVwibGV0IG9wdGlvbiBvZiBmaWx0ZXJlZE9wdGlvbnMkIHwgYXN5bmNcIlxuICAgICAgICAgICAgW3ZhbHVlXT1cIm9wdGlvblwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAge3tcbiAgICAgICAgICAgICAgb3B0aW9uW1xuICAgICAgICAgICAgICAgIGZpZWxkLm1ldGFEYXRhLmFkZENvbmZpZy5iZWxvbmdUb01hbnlPcHRpb25zLnRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICA/IGZpZWxkLm1ldGFEYXRhLmFkZENvbmZpZy5iZWxvbmdUb01hbnlPcHRpb25zLnRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICA6IGZpZWxkLm1ldGFEYXRhLmFkZENvbmZpZy5iZWxvbmdUb01hbnlPcHRpb25zLmZpbHRlcktleXNbMF1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfX1cbiAgICAgICAgICA8L25iLW9wdGlvbj5cbiAgICAgICAgPC9uYi1hdXRvY29tcGxldGU+XG4gICAgICA8L25iLXRhZy1saXN0PlxuICAgIDwvZGl2PlxuICA8L25nLWNvbnRhaW5lcj5cbjwvbmctY29udGFpbmVyPlxuIl19